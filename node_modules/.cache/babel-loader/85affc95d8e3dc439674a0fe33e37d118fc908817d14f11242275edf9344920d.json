{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst percent = require('./percent');\nconst dataProperties = require('./data-properties');\nconst {\n  CoverageSummary\n} = require('./coverage-summary');\n\n// returns a data object that represents empty coverage\nfunction emptyCoverage(filePath, reportLogic) {\n  const cov = {\n    path: filePath,\n    statementMap: {},\n    fnMap: {},\n    branchMap: {},\n    s: {},\n    f: {},\n    b: {}\n  };\n  if (reportLogic) cov.bT = {};\n  return cov;\n}\n\n// asserts that a data object \"looks like\" a coverage object\nfunction assertValidObject(obj) {\n  const valid = obj && obj.path && obj.statementMap && obj.fnMap && obj.branchMap && obj.s && obj.f && obj.b;\n  if (!valid) {\n    throw new Error('Invalid file coverage object, missing keys, found:' + Object.keys(obj).join(','));\n  }\n}\nconst keyFromLoc = ({\n  start,\n  end\n}) => `${start.line}|${start.column}|${end.line}|${end.column}`;\nconst isObj = o => !!o && typeof o === 'object';\nconst isLineCol = o => isObj(o) && typeof o.line === 'number' && typeof o.column === 'number';\nconst isLoc = o => isObj(o) && isLineCol(o.start) && isLineCol(o.end);\nconst getLoc = o => isLoc(o) ? o : isLoc(o.loc) ? o.loc : null;\n\n// When merging, we can have a case where two ranges cover\n// the same block of code with `hits=1`, and each carve out a\n// different range with `hits=0` to indicate it's uncovered.\n// Find the nearest container so that we can properly indicate\n// that both sections are hit.\n// Returns null if no containing item is found.\nconst findNearestContainer = (item, map) => {\n  const itemLoc = getLoc(item);\n  if (!itemLoc) return null;\n  // the B item is not an identified range in the A set, BUT\n  // it may be contained by an identified A range. If so, then\n  // any hit of that containing A range counts as a hit of this\n  // B range as well. We have to find the *narrowest* containing\n  // range to be accurate, since ranges can be hit and un-hit\n  // in a nested fashion.\n  let nearestContainingItem = null;\n  let containerDistance = null;\n  let containerKey = null;\n  for (const [i, mapItem] of Object.entries(map)) {\n    const mapLoc = getLoc(mapItem);\n    if (!mapLoc) continue;\n    // contained if all of line distances are > 0\n    // or line distance is 0 and col dist is >= 0\n    const distance = [itemLoc.start.line - mapLoc.start.line, itemLoc.start.column - mapLoc.start.column, mapLoc.end.line - itemLoc.end.line, mapLoc.end.column - itemLoc.end.column];\n    if (distance[0] < 0 || distance[2] < 0 || distance[0] === 0 && distance[1] < 0 || distance[2] === 0 && distance[3] < 0) {\n      continue;\n    }\n    if (nearestContainingItem === null) {\n      containerDistance = distance;\n      nearestContainingItem = mapItem;\n      containerKey = i;\n      continue;\n    }\n    // closer line more relevant than closer column\n    const closerBefore = distance[0] < containerDistance[0] || distance[0] === 0 && distance[1] < containerDistance[1];\n    const closerAfter = distance[2] < containerDistance[2] || distance[2] === 0 && distance[3] < containerDistance[3];\n    if (closerBefore || closerAfter) {\n      // closer\n      containerDistance = distance;\n      nearestContainingItem = mapItem;\n      containerKey = i;\n    }\n  }\n  return containerKey;\n};\n\n// either add two numbers, or all matching entries in a number[]\nconst addHits = (aHits, bHits) => {\n  if (typeof aHits === 'number' && typeof bHits === 'number') {\n    return aHits + bHits;\n  } else if (Array.isArray(aHits) && Array.isArray(bHits)) {\n    return aHits.map((a, i) => (a || 0) + (bHits[i] || 0));\n  }\n  return null;\n};\nconst addNearestContainerHits = (item, itemHits, map, mapHits) => {\n  const container = findNearestContainer(item, map);\n  if (container) {\n    return addHits(itemHits, mapHits[container]);\n  } else {\n    return itemHits;\n  }\n};\nconst mergeProp = (aHits, aMap, bHits, bMap, itemKey = keyFromLoc) => {\n  const aItems = {};\n  for (const [key, itemHits] of Object.entries(aHits)) {\n    const item = aMap[key];\n    aItems[itemKey(item)] = [itemHits, item];\n  }\n  const bItems = {};\n  for (const [key, itemHits] of Object.entries(bHits)) {\n    const item = bMap[key];\n    bItems[itemKey(item)] = [itemHits, item];\n  }\n  const mergedItems = {};\n  for (const [key, aValue] of Object.entries(aItems)) {\n    let aItemHits = aValue[0];\n    const aItem = aValue[1];\n    const bValue = bItems[key];\n    if (!bValue) {\n      // not an identified range in b, but might be contained by one\n      aItemHits = addNearestContainerHits(aItem, aItemHits, bMap, bHits);\n    } else {\n      // is an identified range in b, so add the hits together\n      aItemHits = addHits(aItemHits, bValue[0]);\n    }\n    mergedItems[key] = [aItemHits, aItem];\n  }\n  // now find the items in b that are not in a. already added matches.\n  for (const [key, bValue] of Object.entries(bItems)) {\n    let bItemHits = bValue[0];\n    const bItem = bValue[1];\n    if (mergedItems[key]) continue;\n    // not an identified range in b, but might be contained by one\n    bItemHits = addNearestContainerHits(bItem, bItemHits, aMap, aHits);\n    mergedItems[key] = [bItemHits, bItem];\n  }\n  const hits = {};\n  const map = {};\n  Object.values(mergedItems).forEach(([itemHits, item], i) => {\n    hits[i] = itemHits;\n    map[i] = item;\n  });\n  return [hits, map];\n};\n\n/**\n * provides a read-only view of coverage for a single file.\n * The deep structure of this object is documented elsewhere. It has the following\n * properties:\n *\n * * `path` - the file path for which coverage is being tracked\n * * `statementMap` - map of statement locations keyed by statement index\n * * `fnMap` - map of function metadata keyed by function index\n * * `branchMap` - map of branch metadata keyed by branch index\n * * `s` - hit counts for statements\n * * `f` - hit count for functions\n * * `b` - hit count for branches\n */\nclass FileCoverage {\n  /**\n   * @constructor\n   * @param {Object|FileCoverage|String} pathOrObj is a string that initializes\n   * and empty coverage object with the specified file path or a data object that\n   * has all the required properties for a file coverage object.\n   */\n  constructor(pathOrObj, reportLogic = false) {\n    if (!pathOrObj) {\n      throw new Error('Coverage must be initialized with a path or an object');\n    }\n    if (typeof pathOrObj === 'string') {\n      this.data = emptyCoverage(pathOrObj, reportLogic);\n    } else if (pathOrObj instanceof FileCoverage) {\n      this.data = pathOrObj.data;\n    } else if (typeof pathOrObj === 'object') {\n      this.data = pathOrObj;\n    } else {\n      throw new Error('Invalid argument to coverage constructor');\n    }\n    assertValidObject(this.data);\n  }\n\n  /**\n   * returns computed line coverage from statement coverage.\n   * This is a map of hits keyed by line number in the source.\n   */\n  getLineCoverage() {\n    const statementMap = this.data.statementMap;\n    const statements = this.data.s;\n    const lineMap = Object.create(null);\n    Object.entries(statements).forEach(([st, count]) => {\n      /* istanbul ignore if: is this even possible? */\n      if (!statementMap[st]) {\n        return;\n      }\n      const {\n        line\n      } = statementMap[st].start;\n      const prevVal = lineMap[line];\n      if (prevVal === undefined || prevVal < count) {\n        lineMap[line] = count;\n      }\n    });\n    return lineMap;\n  }\n\n  /**\n   * returns an array of uncovered line numbers.\n   * @returns {Array} an array of line numbers for which no hits have been\n   *  collected.\n   */\n  getUncoveredLines() {\n    const lc = this.getLineCoverage();\n    const ret = [];\n    Object.entries(lc).forEach(([l, hits]) => {\n      if (hits === 0) {\n        ret.push(l);\n      }\n    });\n    return ret;\n  }\n\n  /**\n   * returns a map of branch coverage by source line number.\n   * @returns {Object} an object keyed by line number. Each object\n   * has a `covered`, `total` and `coverage` (percentage) property.\n   */\n  getBranchCoverageByLine() {\n    const branchMap = this.branchMap;\n    const branches = this.b;\n    const ret = {};\n    Object.entries(branchMap).forEach(([k, map]) => {\n      const line = map.line || map.loc.start.line;\n      const branchData = branches[k];\n      ret[line] = ret[line] || [];\n      ret[line].push(...branchData);\n    });\n    Object.entries(ret).forEach(([k, dataArray]) => {\n      const covered = dataArray.filter(item => item > 0);\n      const coverage = covered.length / dataArray.length * 100;\n      ret[k] = {\n        covered: covered.length,\n        total: dataArray.length,\n        coverage\n      };\n    });\n    return ret;\n  }\n\n  /**\n   * return a JSON-serializable POJO for this file coverage object\n   */\n  toJSON() {\n    return this.data;\n  }\n\n  /**\n   * merges a second coverage object into this one, updating hit counts\n   * @param {FileCoverage} other - the coverage object to be merged into this one.\n   *  Note that the other object should have the same structure as this one (same file).\n   */\n  merge(other) {\n    if (other.all === true) {\n      return;\n    }\n    if (this.all === true) {\n      this.data = other.data;\n      return;\n    }\n    let [hits, map] = mergeProp(this.s, this.statementMap, other.s, other.statementMap);\n    this.data.s = hits;\n    this.data.statementMap = map;\n    const keyFromLocProp = x => keyFromLoc(x.loc);\n    const keyFromLocationsProp = x => keyFromLoc(x.locations[0]);\n    [hits, map] = mergeProp(this.f, this.fnMap, other.f, other.fnMap, keyFromLocProp);\n    this.data.f = hits;\n    this.data.fnMap = map;\n    [hits, map] = mergeProp(this.b, this.branchMap, other.b, other.branchMap, keyFromLocationsProp);\n    this.data.b = hits;\n    this.data.branchMap = map;\n\n    // Tracking additional information about branch truthiness\n    // can be optionally enabled:\n    if (this.bT && other.bT) {\n      [hits, map] = mergeProp(this.bT, this.branchMap, other.bT, other.branchMap, keyFromLocationsProp);\n      this.data.bT = hits;\n    }\n  }\n  computeSimpleTotals(property) {\n    let stats = this[property];\n    if (typeof stats === 'function') {\n      stats = stats.call(this);\n    }\n    const ret = {\n      total: Object.keys(stats).length,\n      covered: Object.values(stats).filter(v => !!v).length,\n      skipped: 0\n    };\n    ret.pct = percent(ret.covered, ret.total);\n    return ret;\n  }\n  computeBranchTotals(property) {\n    const stats = this[property];\n    const ret = {\n      total: 0,\n      covered: 0,\n      skipped: 0\n    };\n    Object.values(stats).forEach(branches => {\n      ret.covered += branches.filter(hits => hits > 0).length;\n      ret.total += branches.length;\n    });\n    ret.pct = percent(ret.covered, ret.total);\n    return ret;\n  }\n\n  /**\n   * resets hit counts for all statements, functions and branches\n   * in this coverage object resulting in zero coverage.\n   */\n  resetHits() {\n    const statements = this.s;\n    const functions = this.f;\n    const branches = this.b;\n    const branchesTrue = this.bT;\n    Object.keys(statements).forEach(s => {\n      statements[s] = 0;\n    });\n    Object.keys(functions).forEach(f => {\n      functions[f] = 0;\n    });\n    Object.keys(branches).forEach(b => {\n      branches[b].fill(0);\n    });\n    // Tracking additional information about branch truthiness\n    // can be optionally enabled:\n    if (branchesTrue) {\n      Object.keys(branchesTrue).forEach(bT => {\n        branchesTrue[bT].fill(0);\n      });\n    }\n  }\n\n  /**\n   * returns a CoverageSummary for this file coverage object\n   * @returns {CoverageSummary}\n   */\n  toSummary() {\n    const ret = {};\n    ret.lines = this.computeSimpleTotals('getLineCoverage');\n    ret.functions = this.computeSimpleTotals('f', 'fnMap');\n    ret.statements = this.computeSimpleTotals('s', 'statementMap');\n    ret.branches = this.computeBranchTotals('b');\n    // Tracking additional information about branch truthiness\n    // can be optionally enabled:\n    if (this.bT) {\n      ret.branchesTrue = this.computeBranchTotals('bT');\n    }\n    return new CoverageSummary(ret);\n  }\n}\n\n// expose coverage data attributes\ndataProperties(FileCoverage, ['path', 'statementMap', 'fnMap', 'branchMap', 's', 'f', 'b', 'bT', 'all']);\nmodule.exports = {\n  FileCoverage,\n  // exported for testing\n  findNearestContainer,\n  addHits,\n  addNearestContainerHits\n};","map":{"version":3,"names":["percent","require","dataProperties","CoverageSummary","emptyCoverage","filePath","reportLogic","cov","path","statementMap","fnMap","branchMap","s","f","b","bT","assertValidObject","obj","valid","Error","Object","keys","join","keyFromLoc","start","end","line","column","isObj","o","isLineCol","isLoc","getLoc","loc","findNearestContainer","item","map","itemLoc","nearestContainingItem","containerDistance","containerKey","i","mapItem","entries","mapLoc","distance","closerBefore","closerAfter","addHits","aHits","bHits","Array","isArray","a","addNearestContainerHits","itemHits","mapHits","container","mergeProp","aMap","bMap","itemKey","aItems","key","bItems","mergedItems","aValue","aItemHits","aItem","bValue","bItemHits","bItem","hits","values","forEach","FileCoverage","constructor","pathOrObj","data","getLineCoverage","statements","lineMap","create","st","count","prevVal","undefined","getUncoveredLines","lc","ret","l","push","getBranchCoverageByLine","branches","k","branchData","dataArray","covered","filter","coverage","length","total","toJSON","merge","other","all","keyFromLocProp","x","keyFromLocationsProp","locations","computeSimpleTotals","property","stats","call","v","skipped","pct","computeBranchTotals","resetHits","functions","branchesTrue","fill","toSummary","lines","module","exports"],"sources":["/Users/martintirtawisata/my-react-app-pos/node_modules/istanbul-lib-coverage/lib/file-coverage.js"],"sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst percent = require('./percent');\nconst dataProperties = require('./data-properties');\nconst { CoverageSummary } = require('./coverage-summary');\n\n// returns a data object that represents empty coverage\nfunction emptyCoverage(filePath, reportLogic) {\n    const cov = {\n        path: filePath,\n        statementMap: {},\n        fnMap: {},\n        branchMap: {},\n        s: {},\n        f: {},\n        b: {}\n    };\n    if (reportLogic) cov.bT = {};\n    return cov;\n}\n\n// asserts that a data object \"looks like\" a coverage object\nfunction assertValidObject(obj) {\n    const valid =\n        obj &&\n        obj.path &&\n        obj.statementMap &&\n        obj.fnMap &&\n        obj.branchMap &&\n        obj.s &&\n        obj.f &&\n        obj.b;\n    if (!valid) {\n        throw new Error(\n            'Invalid file coverage object, missing keys, found:' +\n                Object.keys(obj).join(',')\n        );\n    }\n}\n\nconst keyFromLoc = ({ start, end }) =>\n    `${start.line}|${start.column}|${end.line}|${end.column}`;\n\nconst isObj = o => !!o && typeof o === 'object';\nconst isLineCol = o =>\n    isObj(o) && typeof o.line === 'number' && typeof o.column === 'number';\nconst isLoc = o => isObj(o) && isLineCol(o.start) && isLineCol(o.end);\nconst getLoc = o => (isLoc(o) ? o : isLoc(o.loc) ? o.loc : null);\n\n// When merging, we can have a case where two ranges cover\n// the same block of code with `hits=1`, and each carve out a\n// different range with `hits=0` to indicate it's uncovered.\n// Find the nearest container so that we can properly indicate\n// that both sections are hit.\n// Returns null if no containing item is found.\nconst findNearestContainer = (item, map) => {\n    const itemLoc = getLoc(item);\n    if (!itemLoc) return null;\n    // the B item is not an identified range in the A set, BUT\n    // it may be contained by an identified A range. If so, then\n    // any hit of that containing A range counts as a hit of this\n    // B range as well. We have to find the *narrowest* containing\n    // range to be accurate, since ranges can be hit and un-hit\n    // in a nested fashion.\n    let nearestContainingItem = null;\n    let containerDistance = null;\n    let containerKey = null;\n    for (const [i, mapItem] of Object.entries(map)) {\n        const mapLoc = getLoc(mapItem);\n        if (!mapLoc) continue;\n        // contained if all of line distances are > 0\n        // or line distance is 0 and col dist is >= 0\n        const distance = [\n            itemLoc.start.line - mapLoc.start.line,\n            itemLoc.start.column - mapLoc.start.column,\n            mapLoc.end.line - itemLoc.end.line,\n            mapLoc.end.column - itemLoc.end.column\n        ];\n        if (\n            distance[0] < 0 ||\n            distance[2] < 0 ||\n            (distance[0] === 0 && distance[1] < 0) ||\n            (distance[2] === 0 && distance[3] < 0)\n        ) {\n            continue;\n        }\n        if (nearestContainingItem === null) {\n            containerDistance = distance;\n            nearestContainingItem = mapItem;\n            containerKey = i;\n            continue;\n        }\n        // closer line more relevant than closer column\n        const closerBefore =\n            distance[0] < containerDistance[0] ||\n            (distance[0] === 0 && distance[1] < containerDistance[1]);\n        const closerAfter =\n            distance[2] < containerDistance[2] ||\n            (distance[2] === 0 && distance[3] < containerDistance[3]);\n        if (closerBefore || closerAfter) {\n            // closer\n            containerDistance = distance;\n            nearestContainingItem = mapItem;\n            containerKey = i;\n        }\n    }\n    return containerKey;\n};\n\n// either add two numbers, or all matching entries in a number[]\nconst addHits = (aHits, bHits) => {\n    if (typeof aHits === 'number' && typeof bHits === 'number') {\n        return aHits + bHits;\n    } else if (Array.isArray(aHits) && Array.isArray(bHits)) {\n        return aHits.map((a, i) => (a || 0) + (bHits[i] || 0));\n    }\n    return null;\n};\n\nconst addNearestContainerHits = (item, itemHits, map, mapHits) => {\n    const container = findNearestContainer(item, map);\n    if (container) {\n        return addHits(itemHits, mapHits[container]);\n    } else {\n        return itemHits;\n    }\n};\n\nconst mergeProp = (aHits, aMap, bHits, bMap, itemKey = keyFromLoc) => {\n    const aItems = {};\n    for (const [key, itemHits] of Object.entries(aHits)) {\n        const item = aMap[key];\n        aItems[itemKey(item)] = [itemHits, item];\n    }\n    const bItems = {};\n    for (const [key, itemHits] of Object.entries(bHits)) {\n        const item = bMap[key];\n        bItems[itemKey(item)] = [itemHits, item];\n    }\n    const mergedItems = {};\n    for (const [key, aValue] of Object.entries(aItems)) {\n        let aItemHits = aValue[0];\n        const aItem = aValue[1];\n        const bValue = bItems[key];\n        if (!bValue) {\n            // not an identified range in b, but might be contained by one\n            aItemHits = addNearestContainerHits(aItem, aItemHits, bMap, bHits);\n        } else {\n            // is an identified range in b, so add the hits together\n            aItemHits = addHits(aItemHits, bValue[0]);\n        }\n        mergedItems[key] = [aItemHits, aItem];\n    }\n    // now find the items in b that are not in a. already added matches.\n    for (const [key, bValue] of Object.entries(bItems)) {\n        let bItemHits = bValue[0];\n        const bItem = bValue[1];\n        if (mergedItems[key]) continue;\n        // not an identified range in b, but might be contained by one\n        bItemHits = addNearestContainerHits(bItem, bItemHits, aMap, aHits);\n        mergedItems[key] = [bItemHits, bItem];\n    }\n\n    const hits = {};\n    const map = {};\n\n    Object.values(mergedItems).forEach(([itemHits, item], i) => {\n        hits[i] = itemHits;\n        map[i] = item;\n    });\n\n    return [hits, map];\n};\n\n/**\n * provides a read-only view of coverage for a single file.\n * The deep structure of this object is documented elsewhere. It has the following\n * properties:\n *\n * * `path` - the file path for which coverage is being tracked\n * * `statementMap` - map of statement locations keyed by statement index\n * * `fnMap` - map of function metadata keyed by function index\n * * `branchMap` - map of branch metadata keyed by branch index\n * * `s` - hit counts for statements\n * * `f` - hit count for functions\n * * `b` - hit count for branches\n */\nclass FileCoverage {\n    /**\n     * @constructor\n     * @param {Object|FileCoverage|String} pathOrObj is a string that initializes\n     * and empty coverage object with the specified file path or a data object that\n     * has all the required properties for a file coverage object.\n     */\n    constructor(pathOrObj, reportLogic = false) {\n        if (!pathOrObj) {\n            throw new Error(\n                'Coverage must be initialized with a path or an object'\n            );\n        }\n        if (typeof pathOrObj === 'string') {\n            this.data = emptyCoverage(pathOrObj, reportLogic);\n        } else if (pathOrObj instanceof FileCoverage) {\n            this.data = pathOrObj.data;\n        } else if (typeof pathOrObj === 'object') {\n            this.data = pathOrObj;\n        } else {\n            throw new Error('Invalid argument to coverage constructor');\n        }\n        assertValidObject(this.data);\n    }\n\n    /**\n     * returns computed line coverage from statement coverage.\n     * This is a map of hits keyed by line number in the source.\n     */\n    getLineCoverage() {\n        const statementMap = this.data.statementMap;\n        const statements = this.data.s;\n        const lineMap = Object.create(null);\n\n        Object.entries(statements).forEach(([st, count]) => {\n            /* istanbul ignore if: is this even possible? */\n            if (!statementMap[st]) {\n                return;\n            }\n            const { line } = statementMap[st].start;\n            const prevVal = lineMap[line];\n            if (prevVal === undefined || prevVal < count) {\n                lineMap[line] = count;\n            }\n        });\n        return lineMap;\n    }\n\n    /**\n     * returns an array of uncovered line numbers.\n     * @returns {Array} an array of line numbers for which no hits have been\n     *  collected.\n     */\n    getUncoveredLines() {\n        const lc = this.getLineCoverage();\n        const ret = [];\n        Object.entries(lc).forEach(([l, hits]) => {\n            if (hits === 0) {\n                ret.push(l);\n            }\n        });\n        return ret;\n    }\n\n    /**\n     * returns a map of branch coverage by source line number.\n     * @returns {Object} an object keyed by line number. Each object\n     * has a `covered`, `total` and `coverage` (percentage) property.\n     */\n    getBranchCoverageByLine() {\n        const branchMap = this.branchMap;\n        const branches = this.b;\n        const ret = {};\n        Object.entries(branchMap).forEach(([k, map]) => {\n            const line = map.line || map.loc.start.line;\n            const branchData = branches[k];\n            ret[line] = ret[line] || [];\n            ret[line].push(...branchData);\n        });\n        Object.entries(ret).forEach(([k, dataArray]) => {\n            const covered = dataArray.filter(item => item > 0);\n            const coverage = (covered.length / dataArray.length) * 100;\n            ret[k] = {\n                covered: covered.length,\n                total: dataArray.length,\n                coverage\n            };\n        });\n        return ret;\n    }\n\n    /**\n     * return a JSON-serializable POJO for this file coverage object\n     */\n    toJSON() {\n        return this.data;\n    }\n\n    /**\n     * merges a second coverage object into this one, updating hit counts\n     * @param {FileCoverage} other - the coverage object to be merged into this one.\n     *  Note that the other object should have the same structure as this one (same file).\n     */\n    merge(other) {\n        if (other.all === true) {\n            return;\n        }\n\n        if (this.all === true) {\n            this.data = other.data;\n            return;\n        }\n\n        let [hits, map] = mergeProp(\n            this.s,\n            this.statementMap,\n            other.s,\n            other.statementMap\n        );\n        this.data.s = hits;\n        this.data.statementMap = map;\n\n        const keyFromLocProp = x => keyFromLoc(x.loc);\n        const keyFromLocationsProp = x => keyFromLoc(x.locations[0]);\n\n        [hits, map] = mergeProp(\n            this.f,\n            this.fnMap,\n            other.f,\n            other.fnMap,\n            keyFromLocProp\n        );\n        this.data.f = hits;\n        this.data.fnMap = map;\n\n        [hits, map] = mergeProp(\n            this.b,\n            this.branchMap,\n            other.b,\n            other.branchMap,\n            keyFromLocationsProp\n        );\n        this.data.b = hits;\n        this.data.branchMap = map;\n\n        // Tracking additional information about branch truthiness\n        // can be optionally enabled:\n        if (this.bT && other.bT) {\n            [hits, map] = mergeProp(\n                this.bT,\n                this.branchMap,\n                other.bT,\n                other.branchMap,\n                keyFromLocationsProp\n            );\n            this.data.bT = hits;\n        }\n    }\n\n    computeSimpleTotals(property) {\n        let stats = this[property];\n\n        if (typeof stats === 'function') {\n            stats = stats.call(this);\n        }\n\n        const ret = {\n            total: Object.keys(stats).length,\n            covered: Object.values(stats).filter(v => !!v).length,\n            skipped: 0\n        };\n        ret.pct = percent(ret.covered, ret.total);\n        return ret;\n    }\n\n    computeBranchTotals(property) {\n        const stats = this[property];\n        const ret = { total: 0, covered: 0, skipped: 0 };\n\n        Object.values(stats).forEach(branches => {\n            ret.covered += branches.filter(hits => hits > 0).length;\n            ret.total += branches.length;\n        });\n        ret.pct = percent(ret.covered, ret.total);\n        return ret;\n    }\n\n    /**\n     * resets hit counts for all statements, functions and branches\n     * in this coverage object resulting in zero coverage.\n     */\n    resetHits() {\n        const statements = this.s;\n        const functions = this.f;\n        const branches = this.b;\n        const branchesTrue = this.bT;\n        Object.keys(statements).forEach(s => {\n            statements[s] = 0;\n        });\n        Object.keys(functions).forEach(f => {\n            functions[f] = 0;\n        });\n        Object.keys(branches).forEach(b => {\n            branches[b].fill(0);\n        });\n        // Tracking additional information about branch truthiness\n        // can be optionally enabled:\n        if (branchesTrue) {\n            Object.keys(branchesTrue).forEach(bT => {\n                branchesTrue[bT].fill(0);\n            });\n        }\n    }\n\n    /**\n     * returns a CoverageSummary for this file coverage object\n     * @returns {CoverageSummary}\n     */\n    toSummary() {\n        const ret = {};\n        ret.lines = this.computeSimpleTotals('getLineCoverage');\n        ret.functions = this.computeSimpleTotals('f', 'fnMap');\n        ret.statements = this.computeSimpleTotals('s', 'statementMap');\n        ret.branches = this.computeBranchTotals('b');\n        // Tracking additional information about branch truthiness\n        // can be optionally enabled:\n        if (this.bT) {\n            ret.branchesTrue = this.computeBranchTotals('bT');\n        }\n        return new CoverageSummary(ret);\n    }\n}\n\n// expose coverage data attributes\ndataProperties(FileCoverage, [\n    'path',\n    'statementMap',\n    'fnMap',\n    'branchMap',\n    's',\n    'f',\n    'b',\n    'bT',\n    'all'\n]);\n\nmodule.exports = {\n    FileCoverage,\n    // exported for testing\n    findNearestContainer,\n    addHits,\n    addNearestContainerHits\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}